{"version":3,"sources":["node_modules/browser-pack/_prelude.js","src/filters/bulgepinch/BulgePinchFilter.js","src/filters/colorreplace/ColorReplaceFilter.js","src/filters/glow/GlowFilter.js","src/filters/outline/OutlineFilter.js","src/filters/simplelightmap/SimpleLightmapFilter.js","src"],"names":[],"mappings":";;;;;;;AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"pixi-extra-filters.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\n\n/**\n* @author Julien CLEREL @JuloxRox\n* original filter https://github.com/evanw/glfx.js/blob/master/src/filters/warp/bulgepinch.js by Evan Wallace : http://madebyevan.com/\n*/\n\n/**\n* @filter Bulge / Pinch\n* @description Bulges or pinches the image in a circle.\n* @param center The x and y coordinates of the center of the circle of effect.\n* @param radius The radius of the circle of effect.\n* @param strength -1 to 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)\n*\n* @class BulgePinchFilter\n* @extends AbstractFilter\n* @constructor\n*/\n\nfunction BulgePinchFilter() {\n    PIXI.Filter.call(this,\n        // vertex shader\n       // vertex shader\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void){\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}\\n\",\n            // fragment shader\n        \"#define GLSLIFY 1\\nuniform float radius;\\nuniform float strength;\\nuniform vec2 center;\\nuniform sampler2D uSampler;\\nuniform vec4 dimensions;\\nvarying vec2 vTextureCoord;\\nvoid main()\\n{\\n    vec2 coord = vTextureCoord * dimensions.xy;\\n    coord -= center;\\n    float distance = length(coord);\\n    if (distance < radius) {\\n        float percent = distance / radius;\\n        if (strength > 0.0) {\\n            coord *= mix(1.0, smoothstep(0.0, radius /     distance, percent), strength * 0.75);\\n        } else {\\n            coord *= mix(1.0, pow(percent, 1.0 + strength * 0.75) * radius / distance, 1.0 - percent);\\n        }\\n    }\\n    coord += center;\\n    gl_FragColor = texture2D(uSampler, coord / dimensions.xy);\\n    vec2 clampedCoord = clamp(coord, vec2(0.0), dimensions.xy);\\n    if (coord != clampedCoord) {\\n    gl_FragColor.a *= max(0.0, 1.0 - length(coord - clampedCoord));\\n    }\\n}\\n\"\n    );\n}\n\nBulgePinchFilter.prototype = Object.create(PIXI.Filter.prototype);\nBulgePinchFilter.prototype.constructor = BulgePinchFilter;\nmodule.exports = BulgePinchFilter;\n\nObject.defineProperties(BulgePinchFilter.prototype, {\n    /**\n     * The radius of the circle of effect.\n     *\n     * @property radius\n     * @type Number\n     */\n    radius: {\n        get: function ()\n        {\n            return this.uniforms.radius;\n        },\n        set: function (value)\n        {\n            this.uniforms.radius = value;\n        }\n    },\n    /**\n     * The strength of the effect. -1 to 1 (-1 is strong pinch, 0 is no effect, 1 is strong bulge)\n     *\n     * @property strength\n     * @type Number\n     */\n    strength: {\n        get: function ()\n        {\n            return this.uniforms.strength;\n        },\n        set: function (value)\n        {\n            this.uniforms.strength = value;\n        }\n    },\n    /**\n     * The x and y coordinates of the center of the circle of effect.\n     *\n     * @property center\n     * @type Point\n     */\n    center: {\n        get: function ()\n        {\n            return this.uniforms.center;\n        },\n        set: function (value)\n        {\n            this.uniforms.center = value;\n        }\n    }\n});\n","\n\n/**\n * ColorReplaceFilter, originally by mishaa, updated by timetocode\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966\n *\n * @class\n * @param originalColor {FloatArray32} The color that will be changed, as a 3 component RGB e.g. new Float32Array(1.0, 1.0, 1.0)\n * @param newColor {FloatArray32} The resulting color, as a 3 component RGB e.g. new Float32Array(1.0, 0.5, 1.0)\n * @param epsilon {float} Tolerance/sensitivity of the floating-point comparison between colors (lower = more exact, higher = more inclusive)\n *\n * @example\n *  // replaces true red with true blue\n *  someSprite.shader = new ColorReplaceFilter(\n *   new Float32Array([1, 0, 0]),\n *   new Float32Array([0, 0, 1]),\n *   0.001\n *  );\n *  // replaces the RGB color 220, 220, 220 with the RGB color 225, 200, 215\n *  someOtherSprite.shader = new ColorReplaceFilter(\n *   new Float32Array([220/255.0, 220/255.0, 220/255.0]),\n *   new Float32Array([225/255.0, 200/255.0, 215/255.0]),\n *   0.001\n *  );\n *\n */\nfunction ColorReplaceFilter(originalColor, newColor, epsilon) {\n    PIXI.Filter.call(this,\n        // vertex shader\n        // vertex shader\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void){\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}\\n\",\n        // fragment shader\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nuniform sampler2D texture;\\nuniform vec3 originalColor;\\nuniform vec3 newColor;\\nuniform float epsilon;\\nvoid main(void) {\\n    vec4 currentColor = texture2D(texture, vTextureCoord);\\n    vec3 colorDiff = originalColor - (currentColor.rgb / max(currentColor.a, 0.0000000001));\\n    float colorDistance = length(colorDiff);\\n    float doReplace = step(colorDistance, epsilon);\\n    gl_FragColor = vec4(mix(currentColor.rgb, (newColor + colorDiff) * currentColor.a, doReplace), currentColor.a);\\n}\\n\"\n    );\n\n    this.uniforms.originalColor = originalColor;\n    this.uniforms.newColor = newColor;\n    this.uniforms.epsilon = epsilon;\n}\n\nColorReplaceFilter.prototype = Object.create(PIXI.Filter.prototype);\nColorReplaceFilter.prototype.constructor = ColorReplaceFilter;\nmodule.exports = ColorReplaceFilter;\n\nObject.defineProperty(ColorReplaceFilter.prototype, 'originalColor', {\n  set: function (value) {\n    var r = ((value & 0xFF0000) >> 16) / 255,\n        g = ((value & 0x00FF00) >> 8) / 255,\n        b = (value & 0x0000FF) / 255;\n    this.uniforms.originalColor = { x: r, y: g, z: b };\n  }\n});\n\nObject.defineProperty(ColorReplaceFilter.prototype, 'newColor', {\n  set: function (value) {\n    var r = ((value & 0xFF0000) >> 16) / 255,\n        g = ((value & 0x00FF00) >> 8) / 255,\n        b = (value & 0x0000FF) / 255;\n    this.uniforms.newColor = { x: r, y: g, z: b };\n  }\n});\n\nObject.defineProperty(ColorReplaceFilter.prototype, 'epsilon', {\n  set: function (value) {\n    this.uniforms.epsilon = value;\n  }\n});\n","\n\n/**\n * GlowFilter, originally by mishaa\n * http://www.html5gamedevs.com/topic/12756-glow-filter/?hl=mishaa#entry73578\n * http://codepen.io/mishaa/pen/raKzrm\n *\n * @class\n * @param distance {number} The distance of the glow. Make it 2 times more for resolution=2. It cant be changed after filter creation\n * @param outerStrength {number} The strength of the glow outward from the edge of the sprite.\n * @param innerStrength {number} The strength of the glow inward from the edge of the sprite.\n * @param color {number} The color of the glow.\n * @param quality {number} A number between 0 and 1 that describes the quality of the glow.\n *\n * @example\n *  someSprite.filters = [\n *      new GlowFilter(15, 2, 1, 0xFF0000, 0.5)\n *  ];\n */\nfunction GlowFilter(distance, outerStrength, innerStrength, color, quality) {\n    PIXI.Filter.call(this,\n        // vertex shader\n        // vertex shader\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void){\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}\\n\",\n        // fragment shader\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nvarying vec4 vColor;\\n\\nuniform sampler2D uSampler;\\n\\nuniform float distance;\\nuniform float outerStrength;\\nuniform float innerStrength;\\nuniform vec4 glowColor;\\nuniform vec4 filterArea;\\nvec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\\n\\nvoid main(void) {\\n    const float PI = 3.14159265358979323846264;\\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\\n    vec4 curColor;\\n    float totalAlpha = 0.0;\\n    float maxTotalAlpha = 0.0;\\n    float cosAngle;\\n    float sinAngle;\\n    for (float angle = 0.0; angle <= PI * 2.0; angle += %QUALITY_DIST%) {\\n       cosAngle = cos(angle);\\n       sinAngle = sin(angle);\\n       for (float curDistance = 1.0; curDistance <= %DIST%; curDistance++) {\\n           curColor = texture2D(uSampler, vec2(vTextureCoord.x + cosAngle * curDistance * px.x, vTextureCoord.y + sinAngle * curDistance * px.y));\\n           totalAlpha += (distance - curDistance) * curColor.a;\\n           maxTotalAlpha += (distance - curDistance);\\n       }\\n    }\\n    maxTotalAlpha = max(maxTotalAlpha, 0.0001);\\n\\n    ownColor.a = max(ownColor.a, 0.0001);\\n    ownColor.rgb = ownColor.rgb / ownColor.a;\\n    float outerGlowAlpha = (totalAlpha / maxTotalAlpha)  * outerStrength * (1. - ownColor.a);\\n    float innerGlowAlpha = ((maxTotalAlpha - totalAlpha) / maxTotalAlpha) * innerStrength * ownColor.a;\\n    float resultAlpha = (ownColor.a + outerGlowAlpha);\\n    gl_FragColor = vec4(mix(mix(ownColor.rgb, glowColor.rgb, innerGlowAlpha / ownColor.a), glowColor.rgb, outerGlowAlpha / resultAlpha) * resultAlpha, resultAlpha);\\n}\\n\"\n            .replace(/%QUALITY_DIST%/gi, '' + (1 / quality / distance).toFixed(7))\n            .replace(/%DIST%/gi, '' + distance.toFixed(7))\n    );\n\n    this.uniforms.distance = distance;\n    this.uniforms.glowColor = new Float32Array([0, 0, 0, 1]);\n\n    quality = Math.pow(quality, 1/3);\n    this.quality = quality;\n\n    this.uniforms.distance.value *= quality;\n\n    this.color = color;\n    this.outerStrength = outerStrength;\n    this.innerStrength = innerStrength;\n}\n\nGlowFilter.prototype = Object.create(PIXI.Filter.prototype);\nGlowFilter.prototype.constructor = GlowFilter;\nmodule.exports = GlowFilter;\n\nObject.defineProperties(GlowFilter.prototype, {\n    color: {\n        get: function () {\n            return PIXI.utils.rgb2hex(this.uniforms.glowColor);\n        },\n        set: function(value) {\n            PIXI.utils.hex2rgb(value, this.uniforms.glowColor);\n        }\n    },\n\n    outerStrength: {\n        get: function () {\n            return this.uniforms.outerStrength;\n        },\n        set: function (value) {\n            this.uniforms.outerStrength = value;\n        }\n    },\n\n    innerStrength: {\n        get: function () {\n            return this.uniforms.innerStrength;\n        },\n        set: function (value) {\n            this.uniforms.innerStrength = value;\n        }\n    }\n});\n","\n\n/**\n * OutlineFilter, originally by mishaa\n * http://www.html5gamedevs.com/topic/10640-outline-a-sprite-change-certain-colors/?p=69966\n * http://codepen.io/mishaa/pen/emGNRB\n *\n * @class\n * @param thickness {number} The tickness of the outline. Make it 2 times more for resolution 2\n * @param color {number} The color of the glow.\n *\n * @example\n *  someSprite.shader = new OutlineFilter(9, 0xFF0000);\n */\nfunction OutlineFilter(thickness, color) {\n    thickness = thickness || 1;\n    PIXI.Filter.call(this,\n        // vertex shader\n        // vertex shader\n        \"#define GLSLIFY 1\\nattribute vec2 aVertexPosition;\\nattribute vec2 aTextureCoord;\\n\\nuniform mat3 projectionMatrix;\\nvarying vec2 vTextureCoord;\\n\\nvoid main(void){\\n    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\\n    vTextureCoord = aTextureCoord;\\n}\\n\",\n        // fragment shader\n        \"#define GLSLIFY 1\\nvarying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\n\\nuniform float thickness;\\nuniform vec4 outlineColor;\\nuniform vec4 filterArea;\\nvec2 px = vec2(1.0 / filterArea.x, 1.0 / filterArea.y);\\n\\nvoid main(void) {\\n    const float PI = 3.14159265358979323846264;\\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\\n    vec4 curColor;\\n    float maxAlpha = 0.;\\n    for (float angle = 0.; angle < PI * 2.; angle += %THICKNESS% ) {\\n        curColor = texture2D(uSampler, vec2(vTextureCoord.x + thickness * px.x * cos(angle), vTextureCoord.y + thickness * px.y * sin(angle)));\\n        maxAlpha = max(maxAlpha, curColor.a);\\n    }\\n    float resultAlpha = max(maxAlpha, ownColor.a);\\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\\n}\\n\".replace(/%THICKNESS%/gi, (1.0 / thickness).toFixed(7))\n    );\n\n    this.uniforms.thickness = thickness;\n    this.uniforms.outlineColor = new Float32Array([0, 0, 0, 1]);\n    if (color) {\n        this.color = color;\n    }\n}\n\nOutlineFilter.prototype = Object.create(PIXI.Filter.prototype);\nOutlineFilter.prototype.constructor = OutlineFilter;\nmodule.exports = OutlineFilter;\n\nObject.defineProperties(OutlineFilter.prototype, {\n    color: {\n        get: function () {\n            return PIXI.utils.rgb2hex(this.uniforms.outlineColor);\n        },\n        set: function (value) {\n            PIXI.utils.hex2rgb(value, this.uniforms.outlineColor);\n        }\n    }\n});\n","\n\n/**\n* SimpleLightmap, originally by Oza94\n* http://www.html5gamedevs.com/topic/20027-pixijs-simple-lightmapping/\n* http://codepen.io/Oza94/pen/EPoRxj\n*\n* @class\n* @param lightmapTexture {PIXI.Texture} a texture where your lightmap is rendered\n* @param ambientColor {Array} An RGBA array of the ambient color\n* @param [resolution] {Array} An array for X/Y resolution\n*\n* @example\n*  var lightmapTex = new PIXI.RenderTexture(renderer, 400, 300);\n*\n*  // ... render lightmap on lightmapTex\n*\n*  stageContainer.filters = [\n*    new SimpleLightmapFilter(lightmapTex, [0.3, 0.3, 0.7, 0.5], [1.0, 1.0])\n*  ];\n*/\nfunction SimpleLightmapFilter(lightmapTexture, ambientColor, resolution) {\n    PIXI.Filter.call(this,\n        // vertex shader\n        // vertex shader\n        \"precision mediump float;\\n#define GLSLIFY 1\\n\\nvarying vec2 vTextureCoord;\\nuniform sampler2D uSampler;\\n\\nuniform float thickness;\\nuniform vec4 outlineColor;\\nuniform float pixelWidth;\\nuniform float pixelHeight;\\nvec2 px = vec2(pixelWidth, pixelHeight);\\n\\nvoid main(void) {\\n    const float PI = 3.14159265358979323846264;\\n    vec4 ownColor = texture2D(uSampler, vTextureCoord);\\n    vec4 curColor;\\n    float maxAlpha = 0.;\\n    for (float angle = 0.; angle < PI * 2.; angle +=  + (1 / thickness).toFixed(7) + ) {\\n        curColor = texture2D(uSampler, vec2(vTextureCoord.x + thickness * px.x * cos(angle), vTextureCoord.y + thickness * px.y * sin(angle)));\\n        maxAlpha = max(maxAlpha, curColor.a);\\n    }\\n    float resultAlpha = max(maxAlpha, ownColor.a);\\n    gl_FragColor = vec4((ownColor.rgb + outlineColor.rgb * (1. - ownColor.a)) * resultAlpha, resultAlpha);\\n}\\n\",\n        // fragment shader\n        \"#define GLSLIFY 1\\nvarying vec4 vColor;\\nvarying vec2 vTextureCoord;\\nuniform sampler2D u_texture; //diffuse map\\nuniform sampler2D u_lightmap;   //light map\\nuniform vec2 resolution; //resolution of screen\\nuniform vec4 ambientColor; //ambient RGB, alpha channel is intensity\\nvoid main() {\\n    vec4 diffuseColor = texture2D(u_texture, vTextureCoord);\\n    vec2 lighCoord = (gl_FragCoord.xy / resolution.xy);\\n    vec4 light = texture2D(u_lightmap, vTextureCoord);\\n    vec3 ambient = ambientColor.rgb * ambientColor.a;\\n    vec3 intensity = ambient + light.rgb;\\n    vec3 finalColor = diffuseColor.rgb * intensity;\\n    gl_FragColor = vColor * vec4(finalColor, diffuseColor.a);\\n}\\n\"\n    );\n    this.uniforms.u_lightmap = lightmapTexture;\n    this.uniforms.resolution = new Float32Array(resolution || [1.0, 1.0]);\n    this.uniforms.ambientColor =  new Float32Array(ambientColor);\n}\n\nSimpleLightmapFilter.prototype = Object.create(PIXI.Filter.prototype);\nSimpleLightmapFilter.prototype.constructor = SimpleLightmapFilter;\n\nObject.defineProperties(SimpleLightmapFilter.prototype, {\n    texture: {\n        get: function () {\n            return this.uniforms.u_lightmap;\n        },\n        set: function (value) {\n            this.uniforms.u_lightmap = value;\n        }\n    },\n    color: {\n        get: function () {\n            return this.uniforms.ambientColor;\n        },\n        set: function (value) {\n            this.uniforms.ambientColor = new Float32Array(value);\n        }\n    },\n    resolution: {\n        get: function () {\n            return this.uniforms.resolution;\n        },\n        set: function (value) {\n            this.uniforms.resolution = new Float32Array(value);\n        }\n    }\n});\n\nmodule.exports = SimpleLightmapFilter;\n","module.exports = {\r\n    GlowFilter: require('./filters/glow/GlowFilter'),\r\n    OutlineFilter: require('./filters/outline/OutlineFilter'),\r\n    BulgePinchFilter: require('./filters/bulgepinch/BulgePinchFilter'),\r\n    ColorReplaceFilter: require('./filters/colorreplace/ColorReplaceFilter'),\r\n    SimpleLightmapFilter:\r\n        require('./filters/simplelightmap/SimpleLightmapFilter')\r\n};\r\n\r\nfor (var filter in module.exports) {\r\n    PIXI.filters[filter] = module.exports[filter];\r\n}\r\n"],"sourceRoot":"."}